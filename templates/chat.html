<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat with {{ other_user.username }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='chat.css') }}">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div class="text">
        <h2>Chat with {{ other_user.username }}</h2>
        <div class="chat-box" id="chatBox">
            {% for message in messages %}
                <div class="chat {{ 'you' if message.sender_id == current_user.id else 'them' }}">
                    <strong>{{ message.sender.username }}:</strong> {{ message.body }}
                </div>
            {% endfor %}
        </div>
        
        <div class="form">
            <input type="text" id="messageInput" placeholder="Type your message..." autocomplete="off">
            <button id="sendBtn">Send</button>
        </div>
        
        <div class="call-buttons">
            <button id="callButton">Call</button>
            <button id="hangupButton" disabled>End Call</button>
        </div>
        <div id="callStatus" class="call-status"></div>
        <audio id="remoteAudio" autoplay></audio>
    </div>

    <!-- Call modal -->
    <div id="callModal" class="call-modal">
        <div class="call-box">
            <h3 id="callerName">Incoming call from </h3>
            <audio id="ringtone" loop src="{{ url_for('static', filename='ringtone.mp3') }}"></audio>
            <div class="call-buttons">
                <button id="acceptCall">Accept</button>
                <button id="rejectCall">Reject</button>
            </div>
        </div>
    </div>

    <script>
        // Инициализация переменных
        const socket = io();
        const userId = Number('{{ current_user.id }}');
        const recipientId = Number('{{ other_user.id }}');
        
        // DOM элементы
        const chatBox = document.getElementById('chatBox');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const callButton = document.getElementById('callButton');
        const hangupButton = document.getElementById('hangupButton');
        const remoteAudio = document.getElementById('remoteAudio');
        const callModal = document.getElementById('callModal');
        const callerName = document.getElementById('callerName');
        const ringtone = document.getElementById('ringtone');
        const acceptCall = document.getElementById('acceptCall');
        const rejectCall = document.getElementById('rejectCall');
        const callStatus = document.getElementById('callStatus');

        // Состояние приложения
        let currentCallerId = null;
        let peerConnection = null;
        let localStream = null;
        let callStartTime = null;
        let callTimer = null;
        let isCallActive = false;

        // Конфигурация WebRTC
        const servers = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { 
                    urls: "turn:your-turn-server.com",
                    username: "username",
                    credential: "password"
                }
            ]
        };

        // Инициализация соединения
        socket.emit('join', { user_id: userId });

        // Обработчики сообщений
        sendBtn.onclick = () => {
            const message = messageInput.value.trim();
            if (message) {
                socket.emit('send_message', {
                    message: message,
                    recipient_id: recipientId
                });
                messageInput.value = '';
            }
        };

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendBtn.click();
        });

        socket.on('receive_message', data => {
            const div = document.createElement('div');
            div.className = 'chat ' + (data.user_id === userId ? 'you' : 'them');
            div.innerHTML = `<strong>${data.username}:</strong> ${data.message}`;
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        });

        // Логика звонков
        callButton.onclick = async () => {
            if (isCallActive) return;
            
            callStatus.textContent = "Calling...";
            callButton.disabled = true;
            
            try {
                // Получаем доступ к микрофону
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Создаем PeerConnection
                peerConnection = new RTCPeerConnection(servers);
                
                // Добавляем локальный поток
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Обработка ICE кандидатов
                peerConnection.onicecandidate = ({ candidate }) => {
                    if (candidate) {
                        socket.emit('ice_candidate', { 
                            candidate, 
                            to: recipientId 
                        });
                    }
                };

                // Получение удаленного потока
                peerConnection.ontrack = ({ streams }) => {
                    remoteAudio.srcObject = streams[0];
                    isCallActive = true;
                    startCallTimer();
                };

                // Создаем предложение
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true
                });
                
                await peerConnection.setLocalDescription(offer);
                
                // Отправляем запрос на звонок
                socket.emit('request_call', { 
                    to: recipientId,
                    offer: peerConnection.localDescription
                });
                
            } catch (err) {
                console.error("Call setup failed:", err);
                resetCallState();
                alert("Failed to start call. Please check your microphone permissions.");
            }
        };

        // Входящий вызов
        socket.on('incoming_call', ({from, caller_name}) => {
            if (isCallActive) {
                socket.emit('call_response', {
                    to: from,
                    accepted: false,
                    reason: "Already in call"
                });
                return;
            }
            
            currentCallerId = from;
            callerName.textContent = `Incoming call from ${caller_name}`;
            callModal.style.display = 'flex';
            
            // Воспроизводим рингтон с обработкой ошибок
            ringtone.currentTime = 0;
            ringtone.play().catch(e => {
                console.log("Ringtone play error:", e);
            });
        });

        // Принятие вызова
        acceptCall.onclick = async () => {
            callModal.style.display = 'none';
            stopRingtone();
            
            try {
                // Получаем доступ к микрофону
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                // Создаем PeerConnection
                peerConnection = new RTCPeerConnection(servers);
                
                // Добавляем локальный поток
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Обработка ICE кандидатов
                peerConnection.onicecandidate = ({ candidate }) => {
                    if (candidate) {
                        socket.emit('ice_candidate', { 
                            candidate, 
                            to: currentCallerId 
                        });
                    }
                };

                // Получение удаленного потока
                peerConnection.ontrack = ({ streams }) => {
                    remoteAudio.srcObject = streams[0];
                    isCallActive = true;
                    startCallTimer();
                };

                // Устанавливаем удаленное описание
                await peerConnection.setRemoteDescription(
                    new RTCSessionDescription(callOffer)
                );
                
                // Создаем ответ
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // Отправляем ответ
                socket.emit('call_response', {
                    to: currentCallerId,
                    accepted: true,
                    answer: peerConnection.localDescription
                });
                
                updateCallUI(true);
                
            } catch (err) {
                console.error('Failed to accept call:', err);
                resetCallState();
                alert('Error accepting call. Please try again.');
            }
        };

        // Отклонение вызова
        rejectCall.onclick = () => {
            callModal.style.display = 'none';
            stopRingtone();
            
            socket.emit('call_response', {
                to: currentCallerId,
                accepted: false,
                reason: "Call rejected by user"
            });
            
            resetCallState();
        };

        // Завершение звонка
        hangupButton.onclick = () => {
            socket.emit('end_call', { to: isCallActive ? recipientId : currentCallerId });
            endCall();
        };

        // Обработчики событий WebRTC
        socket.on('call_accepted', async ({ answer }) => {
            try {
                await peerConnection.setRemoteDescription(
                    new RTCSessionDescription(answer)
                );
                isCallActive = true;
                startCallTimer();
            } catch (err) {
                console.error('Failed to set remote description:', err);
                endCall();
            }
        });

        socket.on('call_rejected', ({ reason }) => {
            callStatus.textContent = `Call rejected: ${reason || 'No reason given'}`;
            setTimeout(() => callStatus.textContent = "", 3000);
            resetCallState();
        });

        socket.on('call_ended', () => {
            callStatus.textContent = "Call ended by other party";
            setTimeout(() => callStatus.textContent = "", 3000);
            endCall();
        });

        socket.on('ice_candidate', ({ candidate }) => {
            if (peerConnection && candidate) {
                peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                    .catch(e => console.error('Error adding ICE candidate:', e));
            }
        });

        // Вспомогательные функции
        function updateCallUI(inCall) {
            callButton.disabled = inCall;
            hangupButton.disabled = !inCall;
            if (inCall) {
                callStatus.textContent = "Call in progress";
            } else {
                callStatus.textContent = "";
            }
        }

        function startCallTimer() {
            callStartTime = new Date();
            callTimer = setInterval(() => {
                const duration = Math.floor((new Date() - callStartTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                callStatus.textContent = `Call duration: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            }, 1000);
            updateCallUI(true);
        }

        function stopRingtone() {
            ringtone.pause();
            ringtone.currentTime = 0;
        }

        function endCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            stopRingtone();
            
            if (callTimer) {
                clearInterval(callTimer);
                callTimer = null;
            }
            
            remoteAudio.srcObject = null;
            isCallActive = false;
            currentCallerId = null;
            updateCallUI(false);
        }

        function resetCallState() {
            endCall();
            callModal.style.display = 'none';
            callButton.disabled = false;
        }

        // Обработка закрытия страницы
        window.addEventListener('beforeunload', () => {
            if (isCallActive) {
                socket.emit('end_call', { to: recipientId });
            }
        });
    </script>
</body>
</html>